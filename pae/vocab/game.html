---
---

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>PAE Vocabulary Game</title>
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.0/font/bootstrap-icons.css"
    />
    <link rel="stylesheet" href="../../css/styles.css" />
    <!-- jsPDF for certificate generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  </head>
  <body>
    {% include navigation.html %}
    <div class="game-container">
      <nav class="breadcrumb-nav">
        <a href="../../../" class="text-white">
          <i class="bi bi-house"></i> Home
        </a>
        <span class="text-white-50 mx-2">/</span>
        <a href="../../" class="text-white">PAE</a>
        <span class="text-white-50 mx-2">/</span>
        <a href="../" class="text-white">Vocabulary</a>
        <span class="text-white-50 mx-2">/</span>
        <span class="text-white" id="chapterBreadcrumb">Chapter ?</span>
      </nav>

      <div class="game-card">
        <!-- Section 1: Chapter Info & Team Setup -->
        <div class="game-section active" id="setupSection">
          <h1 class="text-center mb-4">
            <i class="bi bi-gear-fill text-primary"></i>
            <span id="chapterTitle">Chapter ? Vocabulary Game</span>
          </h1>

          <!-- Loading indicator for random mode -->
          <div
            class="alert alert-info text-center"
            id="loadingIndicator"
            style="display: none"
          >
            <div class="spinner-border text-primary me-2" role="status">
              <span class="visually-hidden">Loading...</span>
            </div>
            <strong>Loading Random Categories...</strong>
            <div id="loadingProgress" class="mt-2 small"></div>
          </div>

          <div class="alert alert-info mb-4" id="gameInstructions">
            <h4><i class="bi bi-info-circle"></i> Game Instructions</h4>
            <ol class="mb-0">
              <li>Teams take turns selecting point values (higher = harder)</li>
              <li>You have 30 seconds to answer each question</li>
              <li>If incorrect, the next team can steal for half points</li>
              <li>Only the answering team may talk during their turn</li>
              <li>
                The game will dynamically adjust based on available questions
              </li>
            </ol>
          </div>

          <!-- Random mode info -->
          <div
            class="alert alert-warning mb-4"
            id="randomModeInfo"
            style="display: none"
          >
            <h4><i class="bi bi-shuffle"></i> Random All Chapters Mode</h4>
            <p class="mb-2">
              Categories have been randomly selected from all 17 chapters!
            </p>
            <div id="selectedCategories" class="small"></div>
          </div>

          <!-- Board configuration info -->
          <div
            class="alert alert-success mb-4"
            id="boardConfigInfo"
            style="display: none"
          >
            <h5><i class="bi bi-grid-3x3"></i> Board Configuration</h5>
            <div id="boardConfigDetails"></div>
          </div>

          <div class="row">
            <div class="col-md-8 mx-auto">
              <h3 class="text-center mb-4">Team Setup</h3>
              <div class="mb-3">
                <label class="form-label">Number of teams (2-6):</label>
                <select
                  class="form-control"
                  id="numTeams"
                  onchange="updateTeamInputs()"
                >
                  <option value="2">2 Teams</option>
                  <option value="3">3 Teams</option>
                  <option value="4" selected>4 Teams</option>
                  <option value="5">5 Teams</option>
                  <option value="6">6 Teams</option>
                </select>
              </div>

              <div class="alert alert-info">
                <i class="bi bi-info-circle"></i>
                <strong>Team Member Names:</strong> Enter all team member names
                in each field (separated by commas if multiple students per
                team)
              </div>

              <div id="teamInputs" class="team-setup">
                <!-- Team inputs will be generated here -->
              </div>

              <div class="text-center mt-4">
                <button
                  class="btn btn-primary btn-lg"
                  onclick="startGame()"
                  id="startGameBtn"
                >
                  <i class="bi bi-play-fill"></i> Start Game
                </button>
              </div>
            </div>
          </div>
        </div>

        <!-- Section 2: Game Board -->
        <div class="game-section" id="gameSection">
          <h1 class="text-center mb-3">
            <i class="bi bi-trophy-fill text-warning"></i>
            <span id="gameTitle">Chapter ? Vocabulary Game</span>
          </h1>

          <div class="team-scores" id="teamScores"></div>

          <div class="jeopardy-board" id="gameBoard">
            <!-- Game board will be generated here -->
          </div>

          <div class="text-center mt-3">
            <div
              class="countdown-timer"
              id="questionTimer"
              style="display: none"
            >
              30
            </div>
            <div id="currentTeamDisplay" class="h4 text-primary"></div>
            <div id="questionsRemaining" class="h5 text-muted mt-2"></div>

            <!-- End Game Early Button -->
            <div class="mt-4">
              <button class="btn btn-warning btn-sm" onclick="endGameEarly()">
                <i class="bi bi-stop-circle"></i> End Game Early
              </button>
            </div>
          </div>
        </div>

        <!-- Section 3: Game Complete -->
        <div class="game-section" id="completeSection">
          <h1 class="text-center mb-4">
            <i class="bi bi-trophy text-warning"></i>
            <span id="gameCompleteTitle">Game Complete!</span>
          </h1>

          <div class="alert alert-success text-center" id="gameCompleteAlert">
            <h3>Final Results</h3>
            <div id="finalScores" class="mt-3"></div>
          </div>

          <div class="text-center">
            <button
              class="btn btn-success btn-lg me-3"
              onclick="generateCertificate()"
            >
              <i class="bi bi-download"></i> Get Certificate
            </button>
            <button class="btn btn-primary btn-lg me-3" onclick="playAgain()">
              <i class="bi bi-arrow-repeat"></i> Play Again
            </button>
            <button
              class="btn btn-secondary btn-lg"
              onclick="selectNewChapter()"
            >
              <i class="bi bi-list"></i> Select New Chapter
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- Audio Notice -->
    <div class="audio-notice">
      <i class="bi bi-volume-up"></i> Looking for audio files in: ../../media/
      (correct.mp3, incorrect.mp3, ding-ding.mp3)
    </div>

    <!-- Question Modal -->
    <div class="question-modal" id="questionModal">
      <div class="question-content">
        <h3 id="questionPoints"></h3>
        <p id="questionText" class="fs-5"></p>
        <div id="answerOptions"></div>
        <div class="countdown-timer" id="modalTimer">30</div>
      </div>
    </div>

    <script>
      // Global Variables
      let currentChapter = 1;
      let isRandomMode = false;
      let vocabularyData = {};
      let allChaptersData = {}; // Store all chapter data for random mode
      let selectedRandomCategories = []; // Store the 4 selected categories for random mode
      let gameQuestions = []; // This will hold the selected questions for the game
      let questionPool = {}; // Organized by category and points
      let boardConfiguration = {}; // Store the dynamic board configuration
      let teams = [];
      let currentTeam = 0;
      let gameActive = false;
      let questionTimer = null;
      let currentQuestion = null;
      let currentPoints = 0;
      let gameEndedEarly = false;
      let questionsAnswered = 0;
      let totalQuestionsInGame = 0; // Track the actual number of questions in this game

      // Initialize
      document.addEventListener("DOMContentLoaded", function () {
        // Get chapter from URL parameter
        const urlParams = new URLSearchParams(window.location.search);
        const chapterParam = urlParams.get("chapter");

        if (chapterParam && chapterParam.toLowerCase() === "rand") {
          isRandomMode = true;
          loadRandomChaptersData();
        } else {
          currentChapter = parseInt(chapterParam) || 1;
          loadVocabularyData();
        }

        // Setup initial team inputs
        updateTeamInputs();
      });

      // Load all chapters for random mode
      async function loadRandomChaptersData() {
        document.getElementById("loadingIndicator").style.display = "block";
        document.getElementById("gameInstructions").style.display = "none";
        document.getElementById("startGameBtn").disabled = true;

        const totalChapters = 17;
        let loadedChapters = 0;
        allChaptersData = {};

        // Try to load all 17 chapters
        const loadPromises = [];
        for (let i = 1; i <= totalChapters; i++) {
          loadPromises.push(loadChapterData(i));
        }

        await Promise.allSettled(loadPromises);

        // Check if we have enough data
        const availableChapters = Object.keys(allChaptersData).length;
        if (availableChapters < 4) {
          alert(
            `Only ${availableChapters} chapters available. Need at least 4 for random mode. Using sample data.`
          );
          // Generate sample data for missing chapters
          for (let i = 1; i <= totalChapters; i++) {
            if (!allChaptersData[i]) {
              allChaptersData[i] = generateSampleChapterData(i);
            }
          }
        }

        // Select random categories
        selectRandomCategories();

        // Update UI
        document.getElementById("loadingIndicator").style.display = "none";
        document.getElementById("gameInstructions").style.display = "block";
        document.getElementById("randomModeInfo").style.display = "block";
        document.getElementById("startGameBtn").disabled = false;

        document.getElementById("chapterBreadcrumb").textContent = "Random Mix";
        document.getElementById("chapterTitle").textContent =
          "Random All Chapters Vocabulary Game";
        document.getElementById("gameTitle").textContent =
          "Random All Chapters Vocabulary Game";
      }

      // Load a single chapter's data
      async function loadChapterData(chapterNum) {
        try {
          document.getElementById(
            "loadingProgress"
          ).textContent = `Loading Chapter ${chapterNum}...`;

          const response = await fetch(`ch${chapterNum}vocab.json`);
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          const data = await response.json();
          allChaptersData[chapterNum] = data;

          console.log(`Loaded Chapter ${chapterNum}: ${data.title}`);
        } catch (error) {
          console.error(`Error loading chapter ${chapterNum}:`, error);
          // Don't store anything for this chapter if it fails
        }
      }

      // Select 4 random categories from all available chapters
      function selectRandomCategories() {
        selectedRandomCategories = [];
        const allAvailableCategories = [];

        // Collect all categories from all chapters with their chapter info
        for (const [chapterNum, chapterData] of Object.entries(
          allChaptersData
        )) {
          if (chapterData.categories && chapterData.questions) {
            chapterData.categories.forEach((category) => {
              // Get all questions for this category
              const categoryQuestions = chapterData.questions.filter(
                (q) => q.category === category
              );
              if (categoryQuestions.length >= 3) {
                // Minimum 3 questions per category
                allAvailableCategories.push({
                  category: category,
                  chapter: parseInt(chapterNum),
                  chapterTitle: chapterData.title || `Chapter ${chapterNum}`,
                  questions: categoryQuestions,
                });
              }
            });
          }
        }

        // Shuffle and select 4 categories
        const shuffled = allAvailableCategories.sort(() => Math.random() - 0.5);
        selectedRandomCategories = shuffled.slice(0, 4);

        // Display selected categories
        const categoriesDisplay = document.getElementById("selectedCategories");
        categoriesDisplay.innerHTML =
          "<strong>Selected Categories:</strong><br>";
        selectedRandomCategories.forEach((cat, index) => {
          categoriesDisplay.innerHTML += `${index + 1}. <strong>${
            cat.category
          }</strong> (from ${cat.chapterTitle})<br>`;
        });

        // Prepare the vocabulary data structure for the game
        vocabularyData = {
          title: "Random All Chapters",
          categories: selectedRandomCategories.map((c) => c.category),
          questions: [],
        };

        // Combine all questions from selected categories
        selectedRandomCategories.forEach((cat) => {
          cat.questions.forEach((q) => {
            vocabularyData.questions.push({
              ...q,
              sourceChapter: cat.chapter,
              sourceChapterTitle: cat.chapterTitle,
            });
          });
        });

        console.log(
          `Selected ${selectedRandomCategories.length} random categories with ${vocabularyData.questions.length} total questions`
        );
      }

      // Generate sample chapter data if file not found
      function generateSampleChapterData(chapterNum) {
        const categories = [
          `Ch${chapterNum} Category A`,
          `Ch${chapterNum} Category B`,
          `Ch${chapterNum} Category C`,
          `Ch${chapterNum} Category D`,
        ];

        const questions = [];
        let index = 0;

        categories.forEach((category) => {
          [100, 200, 300, 400, 500].forEach((points) => {
            questions.push({
              index: index++,
              points: points,
              category: category,
              definition: `Sample definition from Chapter ${chapterNum}, ${category} at ${points} points`,
              choices: [
                `Option A-${chapterNum}`,
                `Option B-${chapterNum}`,
                `Correct Answer-${chapterNum}`,
                `Option D-${chapterNum}`,
              ],
              correct: `Correct Answer-${chapterNum}`,
            });
          });
        });

        return {
          chapter: chapterNum,
          title: `Chapter ${chapterNum} (Sample)`,
          categories: categories,
          questions: questions,
        };
      }

      // Load vocabulary data from JSON file (single chapter mode)
      async function loadVocabularyData() {
        try {
          const response = await fetch(`ch${currentChapter}vocab.json`);
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          vocabularyData = await response.json();

          // Update UI with chapter info from loaded data
          const chapterTitle =
            vocabularyData.title || `Chapter ${currentChapter}`;
          document.getElementById("chapterBreadcrumb").textContent =
            chapterTitle;
          document.getElementById(
            "chapterTitle"
          ).textContent = `${chapterTitle} Vocabulary Game`;
          document.getElementById(
            "gameTitle"
          ).textContent = `${chapterTitle} Vocabulary Game`;

          console.log(
            `Loaded ${vocabularyData.questions.length} vocabulary items for ${chapterTitle}`
          );

          // Prepare questions for the game
          prepareGameQuestions();
        } catch (error) {
          console.error("Error loading vocabulary data:", error);
          // Use sample data if file not found
          vocabularyData = getSampleData();

          // Update UI with fallback info
          document.getElementById(
            "chapterBreadcrumb"
          ).textContent = `Chapter ${currentChapter}`;
          document.getElementById(
            "chapterTitle"
          ).textContent = `Chapter ${currentChapter} Vocabulary Game`;
          document.getElementById(
            "gameTitle"
          ).textContent = `Chapter ${currentChapter} Vocabulary Game`;

          alert(
            `Could not load ch${currentChapter}vocab.json. Using sample data for demonstration.`
          );

          // Prepare questions even with sample data
          prepareGameQuestions();
        }
      }

      // Dynamically prepare questions based on available data
      function prepareGameQuestions() {
        // Reset the question pool
        questionPool = {};
        gameQuestions = [];
        boardConfiguration = {
          categories: [],
          rows: 3, // Minimum 3 rows
          totalQuestions: 0,
        };

        // Analyze available questions per category
        const categoryAnalysis = {};
        vocabularyData.questions.forEach((question) => {
          const category = question.category || "General";
          if (!categoryAnalysis[category]) {
            categoryAnalysis[category] = {
              questions: [],
              count: 0,
            };
          }
          categoryAnalysis[category].questions.push({ ...question });
          categoryAnalysis[category].count++;
        });

        // Determine which categories have enough questions
        const viableCategories = [];
        const weakCategories = [];

        for (const [category, data] of Object.entries(categoryAnalysis)) {
          if (data.count >= 3) {
            viableCategories.push({
              name: category,
              questions: data.questions,
              count: data.count,
            });
          } else if (data.count > 0) {
            weakCategories.push({
              name: category,
              questions: data.questions,
              count: data.count,
            });
          }
        }

        console.log(
          "Viable categories:",
          viableCategories.map((c) => `${c.name} (${c.count})`)
        );
        console.log(
          "Weak categories:",
          weakCategories.map((c) => `${c.name} (${c.count})`)
        );

        // If we have weak categories, create a MIX category
        let mixCategory = null;
        if (weakCategories.length > 0) {
          mixCategory = {
            name: "MIX",
            questions: [],
            count: 0,
          };

          // Add all weak category questions to MIX
          weakCategories.forEach((cat) => {
            mixCategory.questions.push(...cat.questions);
            mixCategory.count += cat.count;
          });

          // If MIX still needs more questions, borrow from viable categories
          if (mixCategory.count < 3) {
            const needed = 3 - mixCategory.count;
            let borrowed = 0;

            for (const cat of viableCategories) {
              if (borrowed >= needed) break;
              if (cat.count > 3) {
                // This category has extras to spare
                const toTake = Math.min(needed - borrowed, cat.count - 3);
                const borrowedQuestions = cat.questions.splice(
                  cat.count - toTake,
                  toTake
                );
                mixCategory.questions.push(...borrowedQuestions);
                mixCategory.count += toTake;
                cat.count -= toTake;
                borrowed += toTake;
                console.log(
                  `Borrowed ${toTake} questions from ${cat.name} for MIX`
                );
              }
            }
          }
        }

        // Build final category list
        const finalCategories = [...viableCategories];
        if (mixCategory && mixCategory.count >= 3) {
          finalCategories.push(mixCategory);
        }

        // Limit to 4 categories max
        const selectedCategories = finalCategories.slice(0, 4);

        // Determine number of rows based on minimum questions in any category
        const minQuestions = Math.min(
          ...selectedCategories.map((c) => c.count)
        );
        const numRows = Math.min(5, Math.max(3, minQuestions)); // Between 3 and 5 rows

        // Build the board configuration
        boardConfiguration.categories = selectedCategories.map((c) => c.name);
        boardConfiguration.rows = numRows;
        boardConfiguration.totalQuestions = selectedCategories.length * numRows;

        // Display board configuration info
        const configInfo = document.getElementById("boardConfigInfo");
        const configDetails = document.getElementById("boardConfigDetails");
        configInfo.style.display = "block";
        configDetails.innerHTML = `
                <p class="mb-2">Board Size: <strong>${
                  selectedCategories.length
                } categories Ã— ${numRows} rows = ${
          boardConfiguration.totalQuestions
        } questions</strong></p>
                <p class="mb-0">Categories: ${boardConfiguration.categories.join(
                  ", "
                )}</p>
            `;

        // Assign point values dynamically
        const pointValues = [];
        for (let i = 0; i < numRows; i++) {
          pointValues.push((i + 1) * 100);
        }

        // Track used questions
        const usedQuestionIndices = new Set();

        // Build game questions
        selectedCategories.forEach((category, catIndex) => {
          // Sort questions by original points (if available) or randomly
          const sortedQuestions = [...category.questions].sort((a, b) => {
            const pointsA = parseInt(a.points) || 0;
            const pointsB = parseInt(b.points) || 0;
            return pointsA - pointsB || Math.random() - 0.5;
          });

          pointValues.forEach((points, rowIndex) => {
            let selectedQuestion = null;

            // Try to find an unused question
            for (const q of sortedQuestions) {
              if (!usedQuestionIndices.has(q.index)) {
                selectedQuestion = { ...q };
                usedQuestionIndices.add(q.index);
                break;
              }
            }

            if (selectedQuestion) {
              // Assign board position info
              selectedQuestion.boardCategory = catIndex;
              selectedQuestion.boardPoints = points;
              selectedQuestion.displayCategory = category.name;
              selectedQuestion.used = false;

              gameQuestions.push(selectedQuestion);
            }
          });
        });

        totalQuestionsInGame = gameQuestions.length;
        console.log(
          `âœ… Prepared ${totalQuestionsInGame} questions for a ${boardConfiguration.categories.length}Ã—${boardConfiguration.rows} game board`
        );
      }

      // Generate team input fields based on number selected
      function updateTeamInputs() {
        const numTeams = parseInt(document.getElementById("numTeams").value);
        const container = document.getElementById("teamInputs");
        container.innerHTML = "";

        for (let i = 1; i <= numTeams; i++) {
          const div = document.createElement("div");
          div.className = "mb-3";
          div.innerHTML = `
                    <label class="form-label fw-bold">Team ${i} Member Names:</label>
                    <input type="text" class="form-control form-control-lg" id="team${i}" 
                           placeholder="Enter all team member names (e.g., John Doe, Jane Smith)" value="">
                `;
          container.appendChild(div);
        }
      }

      // Start the game
      function startGame() {
        const numTeams = parseInt(document.getElementById("numTeams").value);
        teams = [];

        // Collect team names and members
        for (let i = 1; i <= numTeams; i++) {
          const memberNames =
            document.getElementById(`team${i}`).value || `Team ${i}`;
          teams.push({
            name: `Team ${i}`,
            members: memberNames,
            score: 0,
          });
        }

        // Reset game state
        questionsAnswered = 0;
        gameEndedEarly = false;

        // Prepare questions for the game
        prepareGameQuestions();

        // Switch to game section
        document.getElementById("setupSection").classList.remove("active");
        document.getElementById("gameSection").classList.add("active");

        // Initialize game
        initializeGame();
      }

      // Initialize game board and scoring
      function initializeGame() {
        displayTeamScores();
        setupGameBoard();
        gameActive = true;
        currentTeam = 0;
        updateCurrentTeam();
        updateQuestionsRemaining();
      }

      // Update questions remaining display
      function updateQuestionsRemaining() {
        const remaining = totalQuestionsInGame - questionsAnswered;
        document.getElementById(
          "questionsRemaining"
        ).textContent = `Questions Remaining: ${remaining}/${totalQuestionsInGame}`;
      }

      // Display team scores
      function displayTeamScores() {
        const scoresContainer = document.getElementById("teamScores");
        scoresContainer.innerHTML = "";

        teams.forEach((team, index) => {
          const scoreCard = document.createElement("div");
          scoreCard.className = "team-score-card";
          scoreCard.id = `team-${index}`;
          scoreCard.innerHTML = `
                    <h5>${team.name}</h5>
                    <div class="h3 mb-0">${team.score}</div>
                `;
          scoresContainer.appendChild(scoreCard);
        });
      }

      // Setup dynamic game board
      function setupGameBoard() {
        const gameBoard = document.getElementById("gameBoard");
        gameBoard.innerHTML = "";

        // Set grid columns based on number of categories
        gameBoard.style.gridTemplateColumns = `repeat(${boardConfiguration.categories.length}, 1fr)`;

        // Add category headers
        boardConfiguration.categories.forEach((header) => {
          const headerCell = document.createElement("div");
          headerCell.className = "jeopardy-cell jeopardy-header";

          // Show shortened category names if too long
          if (header.length > 25) {
            headerCell.textContent = header.substring(0, 22) + "...";
            headerCell.title = header; // Full name on hover
          } else {
            headerCell.textContent = header;
          }

          gameBoard.appendChild(headerCell);
        });

        // Create point values grid
        const pointValues = [];
        for (let i = 0; i < boardConfiguration.rows; i++) {
          pointValues.push((i + 1) * 100);
        }

        pointValues.forEach((points) => {
          for (let col = 0; col < boardConfiguration.categories.length; col++) {
            const cell = document.createElement("div");
            cell.className = "jeopardy-cell";
            cell.textContent = points;
            cell.dataset.category = col;
            cell.dataset.points = points;

            // Check if we have a question for this cell
            const hasQuestion = gameQuestions.some(
              (q) =>
                q.boardCategory === col && q.boardPoints === points && !q.used
            );

            if (hasQuestion) {
              cell.onclick = () => handleCellClick(points, col, cell);
            } else {
              cell.classList.add("used"); // Mark as unavailable if no question
            }

            gameBoard.appendChild(cell);
          }
        });
      }

      // Handle game board cell click
      function handleCellClick(points, category, cellElement) {
        if (!gameActive) return;
        if (cellElement.classList.contains("used")) return;

        // Find the specific question for this cell
        const question = gameQuestions.find(
          (q) =>
            q.boardCategory === category && q.boardPoints === points && !q.used
        );

        if (!question) {
          alert("No question available for this cell");
          return;
        }

        // Debug logging
        console.group("ðŸŽ¯ Question Selected");
        if (isRandomMode && question.sourceChapter) {
          console.log(
            `ðŸ“ Source: ch${question.sourceChapter}vocab.json (${
              question.sourceChapterTitle || "Chapter " + question.sourceChapter
            })`
          );
        } else {
          console.log(`ðŸ“ Source: ch${currentChapter}vocab.json`);
        }
        console.log(
          `ðŸ“‚ Category: ${question.displayCategory || question.category}`
        );
        console.log(
          `ðŸ’° Original Points: ${question.originalPoints || question.points}`
        );
        console.log(`ðŸŽ® Board Points: ${points}`);
        console.log(
          `â“ Definition: ${question.definition.substring(0, 50)}...`
        );
        console.log(`âœ… Correct Answer: ${question.correct}`);
        console.groupEnd();

        question.used = true;
        currentQuestion = question;
        currentPoints = points;

        cellElement.classList.add("used");
        showQuestion();
      }

      // Show question modal
      function showQuestion(isSteal = false) {
        const modal = document.getElementById("questionModal");
        let pointsText = isSteal
          ? `${currentPoints} Points (STEAL) - ${teams[currentTeam].name}'s Turn`
          : `${currentPoints} Points - ${teams[currentTeam].name}'s Turn`;

        document.getElementById("questionPoints").textContent = pointsText;
        document.getElementById("questionText").textContent =
          currentQuestion.definition;

        // Display answer options
        const optionsContainer = document.getElementById("answerOptions");
        optionsContainer.innerHTML = "";

        currentQuestion.choices.forEach((choice, index) => {
          const btn = document.createElement("button");
          btn.className = "answer-option";
          btn.textContent = choice;
          btn.type = "button";

          // Use a closure to capture the choice and button element
          (function (selectedChoice, buttonElement) {
            btn.onclick = function (e) {
              e.preventDefault();
              e.stopPropagation();
              checkAnswer(
                selectedChoice === currentQuestion.correct,
                isSteal,
                buttonElement
              );
            };
          })(choice, btn);

          optionsContainer.appendChild(btn);
        });

        modal.classList.add("show");
        startQuestionTimer(isSteal);
      }

      // Start question timer
      function startQuestionTimer(isSteal = false) {
        let timeLeft = 30;
        const timerDisplay = document.getElementById("modalTimer");

        if (questionTimer) clearInterval(questionTimer);

        questionTimer = setInterval(() => {
          timeLeft--;
          timerDisplay.textContent = timeLeft;

          if (timeLeft <= 10) {
            timerDisplay.classList.add("warning");
          }
          if (timeLeft <= 5) {
            timerDisplay.classList.remove("warning");
            timerDisplay.classList.add("danger");
          }

          if (timeLeft <= 0) {
            clearInterval(questionTimer);
            try {
              playSound("ding-ding");
            } catch (e) {
              console.log("Sound error:", e);
            }
            checkAnswer(false, isSteal, null);
          }
        }, 1000);
      }

      // Play sound effect
      function playSound(soundName) {
        try {
          const audio = new Audio(`../../media/${soundName}.mp3`);
          audio.play().catch((e) => console.log("Audio play failed:", e));
        } catch (e) {
          console.log("Audio error:", e);
        }
      }

      // Check answer
      function checkAnswer(isCorrect, isSteal = false, clickedElement = null) {
        clearInterval(questionTimer);

        // Disable all options immediately to prevent double-clicks
        const options = document.querySelectorAll(".answer-option");
        options.forEach((option) => {
          option.disabled = true;
          option.style.pointerEvents = "none";
        });

        if (isCorrect) {
          // Correct answer
          try {
            playSound("correct");
          } catch (e) {
            console.log("Sound error:", e);
          }

          options.forEach((option) => {
            if (option.textContent === currentQuestion.correct) {
              option.classList.add("correct");
            }
          });

          teams[currentTeam].score += currentPoints;
          displayTeamScores();

          questionsAnswered++;
          updateQuestionsRemaining();

          setTimeout(() => {
            closeQuestion();
            nextTeam();
          }, 2000);
        } else {
          // Incorrect answer
          try {
            playSound("incorrect");
          } catch (e) {
            console.log("Sound error:", e);
          }

          if (!isSteal) {
            // First attempt wrong - offer steal
            setTimeout(() => {
              closeQuestion();
              if (
                confirm(
                  `Incorrect! Next team can steal for ${Math.floor(
                    currentPoints / 2
                  )} points?`
                )
              ) {
                nextTeam();
                currentPoints = Math.floor(currentPoints / 2);
                showQuestion(true);
              } else {
                questionsAnswered++;
                updateQuestionsRemaining();
                revealAnswer();
                setTimeout(() => {
                  nextTeam();
                }, 2000);
              }
            }, 1000);
          } else {
            // Steal attempt failed - show correct answer
            options.forEach((option) => {
              if (option.textContent === currentQuestion.correct) {
                option.classList.add("correct");
              } else if (clickedElement && option === clickedElement) {
                option.classList.add("incorrect");
              }
            });

            questionsAnswered++;
            updateQuestionsRemaining();

            setTimeout(() => {
              closeQuestion();
              nextTeam();
            }, 3000);
          }
        }
      }

      // Reveal correct answer
      function revealAnswer() {
        const modal = document.getElementById("questionModal");
        modal.classList.add("show");

        document.getElementById("questionPoints").textContent =
          "Answer Revealed";

        const options = document.querySelectorAll(".answer-option");
        const optionsContainer = document.getElementById("answerOptions");

        options.forEach((option) => {
          option.disabled = true;
          if (option.textContent === currentQuestion.correct) {
            option.classList.add("correct");
          }
        });

        // Add a continue button below the options
        const continueBtn = document.createElement("button");
        continueBtn.className = "btn btn-primary mt-3";
        continueBtn.innerHTML = '<i class="bi bi-arrow-right"></i> Continue';
        continueBtn.onclick = () => {
          closeQuestion();
        };
        optionsContainer.appendChild(continueBtn);
      }

      // Close question modal
      function closeQuestion() {
        document.getElementById("questionModal").classList.remove("show");
        document
          .getElementById("modalTimer")
          .classList.remove("warning", "danger");

        // Reset timer display
        document.getElementById("modalTimer").textContent = "30";

        // Check if game is over (all questions answered)
        if (questionsAnswered >= totalQuestionsInGame) {
          endGame();
        }
      }

      // Move to next team
      function nextTeam() {
        currentTeam = (currentTeam + 1) % teams.length;
        updateCurrentTeam();
      }

      // Update current team display
      function updateCurrentTeam() {
        document.getElementById(
          "currentTeamDisplay"
        ).textContent = `Current Turn: ${teams[currentTeam].name}`;

        document.querySelectorAll(".team-score-card").forEach((card, index) => {
          card.classList.remove("active");
          if (index === currentTeam) {
            card.classList.add("active");
          }
        });
      }

      // End game early function
      function endGameEarly() {
        if (!gameActive) return;

        const confirmation = confirm(
          "Are you sure you want to end the game early? This will show final results with current scores."
        );
        if (confirmation) {
          gameEndedEarly = true;
          clearInterval(questionTimer);

          // Close any open question modal
          document.getElementById("questionModal").classList.remove("show");

          endGame();
        }
      }

      // End game and show results
      function endGame() {
        gameActive = false;

        // Update UI based on how game ended
        if (gameEndedEarly) {
          document.getElementById("gameCompleteTitle").textContent =
            "Game Ended Early";
          document.getElementById("gameCompleteAlert").className =
            "alert alert-warning text-center";
          document.getElementById("gameCompleteAlert").innerHTML = `
                    <h3><i class="bi bi-clock"></i> Game Ended Early</h3>
                    <p class="mb-3">The game was ended before all questions were completed.</p>
                    <p class="mb-3">Questions Answered: ${questionsAnswered}/${totalQuestionsInGame}</p>
                    <div id="finalScores" class="mt-3"></div>
                `;
        } else {
          document.getElementById("gameCompleteTitle").textContent =
            "Game Complete!";
          document.getElementById("gameCompleteAlert").className =
            "alert alert-success text-center";
          document.getElementById("gameCompleteAlert").innerHTML = `
                    <h3>Final Results</h3>
                    <p class="mb-3">All ${totalQuestionsInGame} questions completed!</p>
                    <div id="finalScores" class="mt-3"></div>
                `;
        }

        // Sort teams by score (highest first)
        const sortedTeams = [...teams].sort((a, b) => b.score - a.score);

        // Create rankings display with proper tie handling
        const finalScoresContainer = document.getElementById("finalScores");
        finalScoresContainer.innerHTML = "";

        const rankingsDiv = document.createElement("div");
        rankingsDiv.className = "row justify-content-center";

        let currentRank = 1;
        let previousScore = null;
        let teamsAtSameRank = 0;

        sortedTeams.forEach((team, index) => {
          // Handle tie logic
          if (previousScore !== null && team.score !== previousScore) {
            currentRank = index + 1;
            teamsAtSameRank = 0;
          } else if (previousScore === team.score) {
            teamsAtSameRank++;
          }

          previousScore = team.score;

          const colDiv = document.createElement("div");
          colDiv.className = "col-md-6 mb-3";

          const scoreCard = document.createElement("div");
          scoreCard.className = "team-score-card text-center p-4";

          // Determine rank display and styling
          let rankIcon = "";
          let rankText = "";
          let isTie =
            teamsAtSameRank > 0 ||
            (index < sortedTeams.length - 1 &&
              sortedTeams[index + 1].score === team.score);

          if (currentRank === 1) {
            rankIcon = "ðŸ¥‡";
            rankText = isTie ? "1st Place (Tie)" : "1st Place";
            scoreCard.style.background =
              "linear-gradient(135deg, #fff3cd, #ffeaa7)";
            scoreCard.style.border = "3px solid #ffc107";
          } else if (currentRank === 2) {
            rankIcon = "ðŸ¥ˆ";
            rankText = isTie ? "2nd Place (Tie)" : "2nd Place";
            scoreCard.style.background =
              "linear-gradient(135deg, #e9ecef, #dee2e6)";
            scoreCard.style.border = "2px solid #6c757d";
          } else if (currentRank === 3) {
            rankIcon = "ðŸ¥‰";
            rankText = isTie ? "3rd Place (Tie)" : "3rd Place";
            scoreCard.style.background =
              "linear-gradient(135deg, #f8d7da, #f5c2c7)";
            scoreCard.style.border = "2px solid #dc3545";
          } else {
            rankIcon = "ðŸ†";
            rankText = isTie
              ? `${getOrdinalSuffix(currentRank)} Place (Tie)`
              : `${getOrdinalSuffix(currentRank)} Place`;
            scoreCard.style.background =
              "linear-gradient(135deg, #f8f9fa, #e9ecef)";
            scoreCard.style.border = "2px solid #6c757d";
          }

          scoreCard.innerHTML = `
                    <div class="h1 mb-2">${rankIcon}</div>
                    <h4 class="mb-2">${rankText}</h4>
                    <h5 class="text-primary">${team.name}</h5>
                    <div class="h2 mb-0">${team.score} points</div>
                `;

          colDiv.appendChild(scoreCard);
          rankingsDiv.appendChild(colDiv);
        });

        finalScoresContainer.appendChild(rankingsDiv);

        // Switch to complete section
        document.getElementById("gameSection").classList.remove("active");
        document.getElementById("completeSection").classList.add("active");
      }

      // Helper function to get ordinal suffix
      function getOrdinalSuffix(num) {
        const j = num % 10;
        const k = num % 100;
        if (j == 1 && k != 11) {
          return num + "st";
        }
        if (j == 2 && k != 12) {
          return num + "nd";
        }
        if (j == 3 && k != 13) {
          return num + "rd";
        }
        return num + "th";
      }

      // Restart game with same teams
      function playAgain() {
        // Reset all game state
        teams.forEach((team) => (team.score = 0));
        questionsAnswered = 0;
        currentTeam = 0;
        gameEndedEarly = false;

        // For random mode, reselect categories
        if (isRandomMode) {
          selectRandomCategories();
        }

        // Re-prepare questions for a new game
        prepareGameQuestions();

        // Switch back to game section
        document.getElementById("completeSection").classList.remove("active");
        document.getElementById("gameSection").classList.add("active");

        // Reinitialize game
        initializeGame();
      }

      // Go back to chapter selection
      function selectNewChapter() {
        window.location.href = "index.html";
      }

      // Generate and download certificate
      function generateCertificate() {
        // Prepare certificate data
        const certificateData = {
          gameDate: new Date().toISOString(),
          chapterInfo: isRandomMode
            ? "Random All Chapters"
            : vocabularyData.title || `Chapter ${currentChapter}`,
          isRandomMode: isRandomMode,
          currentChapter: currentChapter,
          gameEndedEarly: gameEndedEarly,
          questionsAnswered: questionsAnswered,
          totalQuestions: totalQuestionsInGame,
          boardConfiguration: boardConfiguration,
          teams: teams.map((team) => ({
            name: team.name,
            members: team.members,
            score: team.score,
          })),
          randomCategories: isRandomMode
            ? selectedRandomCategories.map((cat) => ({
                category: cat.category,
                chapterTitle: cat.chapterTitle,
              }))
            : null,
        };

        // Store in localStorage
        localStorage.setItem(
          "certificateData",
          JSON.stringify(certificateData)
        );

        // Open certificate page in new window/tab
        window.open("certificate.html", "_blank");
      }

      // Sample data for testing
      function getSampleData() {
        // Generate sample data with varied distribution
        const categories = [
          "Category 1",
          "Category 2",
          "Category 3",
          "Category 4",
        ];
        const questions = [];
        let index = 0;

        // Category 1: Full 5 questions
        [100, 200, 300, 400, 500].forEach((points) => {
          questions.push({
            index: index++,
            points: points,
            category: "Category 1",
            definition: `Sample definition for Category 1 at ${points} points`,
            choices: ["Option A", "Option B", "Correct Answer", "Option D"],
            correct: "Correct Answer",
          });
        });

        // Category 2: 4 questions
        [100, 200, 300, 400].forEach((points) => {
          questions.push({
            index: index++,
            points: points,
            category: "Category 2",
            definition: `Sample definition for Category 2 at ${points} points`,
            choices: ["Option A", "Option B", "Correct Answer", "Option D"],
            correct: "Correct Answer",
          });
        });

        // Category 3: 3 questions
        [100, 200, 300].forEach((points) => {
          questions.push({
            index: index++,
            points: points,
            category: "Category 3",
            definition: `Sample definition for Category 3 at ${points} points`,
            choices: ["Option A", "Option B", "Correct Answer", "Option D"],
            correct: "Correct Answer",
          });
        });

        // Category 4: Only 2 questions (will become part of MIX)
        [100, 200].forEach((points) => {
          questions.push({
            index: index++,
            points: points,
            category: "Category 4",
            definition: `Sample definition for Category 4 at ${points} points`,
            choices: ["Option A", "Option B", "Correct Answer", "Option D"],
            correct: "Correct Answer",
          });
        });

        return {
          chapter: currentChapter,
          title: `Chapter ${currentChapter}`,
          description: "Sample data for testing dynamic board sizing",
          categories: categories,
          questions: questions,
        };
      }
    </script>
  </body>
</html>
